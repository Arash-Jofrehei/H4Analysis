#include "TFile.h"
#include "TH1F.h"
#include <iostream>
#include <fstream>
using namespace std;

void analysis() {
    Int_t nbins = 800;
    Int_t j;
    char name[20];
    char title[100];
    TH1F *HistoEvent[2214];
    for (Int_t z=0;z<2214;z++) {
        sprintf(name,"HistoEvent%d",z-1);
        sprintf(title,"Event%d Histo", z-1);
        HistoEvent[z] = new TH1F(name,title,nbins, -0.1, 159.9);
    }
    TH1F *NewHistoEvent[2214];
    for (Int_t z=0;z<2214;z++) {
        sprintf(name,"NewHistoEvent%d",z-1);
        sprintf(title,"Event%d Histo", z-1);
        NewHistoEvent[z] = new TH1F(name,title,nbins, -0.1, 159.9);
    }
    TH1F *NewHistoEventFFT[2214];
    for (Int_t z=0;z<2214;z++) {
        sprintf(name,"NewHistoEventFFT%d",z-1);
        sprintf(title,"Event%d Histo", z-1);
        NewHistoEventFFT[z] = new TH1F(name,title,nbins, 0, 5);
    }
    Double_t mean;
    Double_t rms;
    Double_t meansum = 0;
    Double_t count = 0;
    Double_t meanrms = 0;
	TFile f("/home/marko/H4Analysis/ntuples/analysis_4443.root"); //ntuple generated by H4Analysis tool
	TFile f1("/home/marko/H4Analysis/ntuples/analysis_3905.root");
    TFile outputfile("myoutput.root", "recreate");
    TCanvas* TimeandFreq = new TCanvas("TimeandFreq","Time and Frequency",1500,900);
    TCanvas* Freq = new TCanvas("Freq","Frequency",800,1200);
    TCanvas* TimeSignal = new TCanvas("TimeSignal","Pure Signal",800,1200);
	TimeandFreq->Divide(2,2);
	TTree* h4 = (TTree*) f.Get("h4");
    TTree* h4_2 = (TTree*) f1.Get("h4");
    TString plot;
    TString cut;
	TH2F* WavePulse = new TH2F ("WavePulse", "Wave Pulse", nbins, -0.1, 159.9, 850, -50, 800);
    TH2F* NoisePulse = new TH2F ("NoisePulse", "Noise", nbins, -0.1, 159.9, 100, -50, 50);
    TH1F* PulseTime = new TH1F ("PulseTime", "Original Wave Pulse", nbins, -0.1, 159.9); //nanoseconds
    TH2F* TempHisto = new TH2F ("TempHisto", "Temp Histo", nbins, -0.1, 159.9, 1000, -15, 15); //nanoseconds
	h4->Draw("WF_val:WF_time>>WavePulse", "WF_ch==2 && event==1 && spill==1");
    h4_2->Draw("WF_val:WF_time>>NoisePulse","WF_ch==APD1 && amp_max[APD3]<25 && b_rms[APD3]<5. && charge_tot[APD3]<20000 &&  amp_max[APD5]<25 && b_rms[APD5]<5. &&  amp_max[APD6]<25 && b_rms[APD6]<5. &&  amp_max[APD4]<25 && b_rms[APD4]<5. && amp_max[SiPM1]<20 && amp_max[SiPM2]<20 && amp_max[APD1]<40 && amp_max[APD2]<40 && b_rms[APD1]<5. && b_rms[APD2]<5. && WF_time<160");
    for (Int_t i=0; i<nbins; i++) {
		for (Int_t k=0; k<4096; k++) {
			if (WavePulse->GetBinContent(i+1, k) != 0) {
				PulseTime->SetBinContent(i+1,k-50);
			}
		}
	}
    TH1F *NoiseTime = new TH1F ("NoiseTime", "Noise", nbins, -0.1, 159.9);
    for (Int_t i=0; i<nbins; i++) {
        for (Int_t k=0; k<4096; k++) {
            if (NoisePulse->GetBinContent(i+1, k) != 0) {
                NoiseTime->SetBinContent(i+1,k-62.9087);
            }
        }
    }
    TH1F* NormNoiseFFT = new TH1F ("NormNoiseFFT", "Normalized Noise FFT", nbins, 0, 5);
    TStopwatch t;
    t.Start(); //1 hour runtime
    for (j=10;j<20;j++) {
        plot = "WF_val:WF_time>>TempHisto";
        cut = "WF_ch==APD1 && amp_max[APD3]<25 && b_rms[APD3]<5. && charge_tot[APD3]<20000 &&  amp_max[APD5]<25 && b_rms[APD5]<5. &&  amp_max[APD6]<25 && b_rms[APD6]<5. &&  amp_max[APD4]<25 && b_rms[APD4]<5. && amp_max[SiPM1]<20 && amp_max[SiPM2]<20 && amp_max[APD1]<40 && amp_max[APD2]<40 && b_rms[APD1]<5. && b_rms[APD2]<5. && WF_time<160 && event==";
        cut += j;
        h4_2->Draw(plot, cut, "goff");
        if (TempHisto->GetMaximum() == 0) {
            delete HistoEvent[j+1];
            continue;
        }
        for (Int_t i=0; i<nbins; i++) {
            for (Int_t k=0; k<1000; k++) {
                if (TempHisto->GetBinContent(i+1, k) != 0) {
                    HistoEvent[j+1]->SetBinContent(i+1,k*0.03-15);
                }
            }
        }
        mean = TempHisto->GetMean(2);
        rms = TempHisto->GetRMS(2);
        for (Int_t q=0;q<nbins;q++) {
            NewHistoEvent[j+1]->SetBinContent(q+1, HistoEvent[j+1]->GetBinContent(q+1)-mean);
        }
        NewHistoEvent[j+1]->Scale(1/rms);
        NewHistoEvent[j+1]->FFT(NewHistoEventFFT[j+1], "MAG");
        NormNoiseFFT->Add(NormNoiseFFT, NewHistoEventFFT[j+1]);
        TempHisto->Write();
        NewHistoEvent[j+1]->Write();
        NewHistoEventFFT[j+1]->Write();
        cout << "Event " << j << ", Mean = " << mean << ", RMS = " << rms << endl;
        count += 1;
    }
    NormNoiseFFT->Scale(1/count);
    NormNoiseFFT->Write();
    t.Stop();
    t.Print();
	new TFile("/home/marko/H4Analysis/ntuples/analysis_4443.root"); // ignore this reloading of the same file, it is required or else the plots do not show up (when I tried)
    TimeandFreq->cd(1);
    PulseTime->GetXaxis()->SetTitle("Time (ns)");
    PulseTime->GetYaxis()->SetTitle("Amplitude");
    PulseTime->DrawClone(); //Wave Pulse in Time domain
    TimeandFreq->cd(2);
    TH1F* PulseFreq = new TH1F ("PulseFreq", "Pulse FFT", nbins, 0, 5);
    TH1F* PulsePhase = new TH1F ("PulsePhase", "Pulse Phase", nbins, -0.1, 799.9);
    PulseTime->FFT(PulseFreq, "MAG");
    PulseTime->FFT(PulsePhase, "PH");
    PulseFreq->SetLineColor(kRed);
    PulseFreq->GetXaxis()->SetTitle("Frequency (GHz)");
    PulseFreq->GetYaxis()->SetTitle("Amplitude");
    PulseFreq->DrawClone(); //Wave Pulse in Frequency domain
    gPad->SetLogy();
    TimeandFreq->cd(3);
    NoiseTime->GetXaxis()->SetTitle("Time (ns)");
    NoiseTime->GetYaxis()->SetTitle("Amplitude");
    NoiseTime->DrawClone(); // Noise from pedestal in Time domain
    TimeandFreq->cd(4);
    TH1F* NoiseFreq = new TH1F ("NoiseFreq", "Noise FFT", nbins, 0, 5);
    NoiseTime->FFT(NoiseFreq, "MAG");
    NoiseFreq->GetXaxis()->SetTitle("Frequency (GHz)");
    NoiseFreq->GetYaxis()->SetTitle("Amplitude");
    NoiseFreq->Draw(); // Noise from pedestal in Frequency domain
    gPad->SetLogy();
    Freq->Divide(1,3);
    Freq->cd(1);
    PulseFreq->DrawClone();
    gPad->SetLogy();
    Freq->cd(2);
    NoiseFreq->DrawClone();
    gPad->SetLogy();
    Freq->cd(3);
    PulseFreq->SetTitle("Pulse and Noise FFT Comparison");
    PulseFreq->Draw();
    NoiseFreq->Draw("same");
    gPad->SetLogy();
    TH1F* UnscaledSignalFreq = new TH1F ("UnscaledSignalFreq", "Unscaled Signal Frequency", nbins, -0.1, 799.9);
    for (Int_t l=0; l<nbins; l++) {
        UnscaledSignalFreq->SetBinContent(l+1, (PulseFreq->GetBinContent(l+1)-NoiseFreq->GetBinContent(l+1))/PulseFreq->GetBinContent(l+1));
    }
    TH1F* SignalFreq = new TH1F ("SignalFreq", "Signal Frequency", nbins, 0, 799.9);
    for (Int_t m=0; m<nbins; m++) {
        SignalFreq->SetBinContent(m+1, UnscaledSignalFreq->GetBinContent(m+1)*PulseFreq->GetBinContent(m+1));
    }
    Double_t *re_full = new Double_t[nbins];
    Double_t *im_full = new Double_t[nbins];
    for (Int_t n=0; n<nbins; n++) {
        (re_full)[n]=(SignalFreq->GetBinContent(n+1)*cos(PulsePhase->GetBinContent(n+1)));
        (im_full)[n]=(SignalFreq->GetBinContent(n+1)*sin(PulsePhase->GetBinContent(n+1)));
    }
    TVirtualFFT *invFFT = TVirtualFFT::FFT(1, &nbins, "C2R M K");
    invFFT->SetPointsComplex(re_full, im_full);
    invFFT->Transform();
    TH1 *Signal = 0;
    Signal = TH1::TransformHisto(invFFT,Signal,"Re");
    Signal->SetTitle("Recovered Signal 'S'");
    TH1F* BetterSignal = new TH1F ("BetterSignal", "Recovered Signal", nbins, -0.1, 159.9);
    for (Int_t p=0; p<nbins; p++) {
        BetterSignal->SetBinContent(p+1, Signal->GetBinContent(p+1)/nbins);
    }
    TimeSignal->Divide(1,2);
    TimeSignal->cd(1);
    PulseTime->DrawClone(); //Original Wave Pulse
    TimeSignal->cd(2);
    BetterSignal->GetXaxis()->SetTitle("Time (ns)");
    BetterSignal->GetYaxis()->SetTitle("Amplitude");
    BetterSignal->SetLineColor(kRed);
    BetterSignal->Draw(); // Recovered Wave Pulse with decreased contribution from background noise
    PulseTime->DrawClone("same");
}


//for (Int_t k=0; k<PulseTime->GetNbinsX(); k++) {
//        NoiseTime->SetBinContent(k+1, PulseTime->GetBinContent((k+1)%250));
//}

//h4->Draw("WF_val:WF_time"," WF_ch==APD1 && amp_max[APD3]<25 && b_rms[APD3]<5. && charge_tot[APD3]<20000 &&  amp_max[APD5]<25 && b_rms[APD5]<5. &&  amp_max[APD6]<25 && b_rms[APD6]<5. &&  amp_max[APD4]<25 && b_rms[APD4]<5. && amp_max[SiPM1]<20 && amp_max[SiPM2]<20 && amp_max[APD1]<40 && amp_max[APD2]<40 && b_rms[APD1]<5. && b_rms[APD2]<5.");


//gPad->SetGrid();

// Double_t binCenter = xaxis->GetBinCenter(bin); //where bin is a number corresponding to a bin
// Int_t BinSize = htemp->GetNBins();
// TAxis *xaxis = htemp->GetXaxis();
// TAxis *yaxis = htemp->GetYaxis();

//NoiseTime->GetXaxis()()->SetRangeUser(10,990);

//Freq->cd(4);
//UnscaledSignalFreq->DrawClone();

//NoiseTime->SetBinContent(k+1, sin(k/10.)/10.);


// TH2F* WavePulse=(TH2F*)gDirectory->Get("htemp");

// TTree *MyTree = new TTree("MyTree", "MyTree");
// MyTree->ReadFile("storage.txt", "x:y");
// MyTree->Draw("y:x","");
// TimeandFreq->cd(1);
// WavePulse->DrawClone("colz");
//NoiseTime->SetTitle("FFT");

//Double_t PulseFreqIntegral = PulseFreq->Integral();
//Double_t NoiseFreqIntegral = NoiseFreq->Integral();
//PulseFreq->Scale(1/PulseFreqIntegral);
//NoiseFreq->Scale(1/NoiseFreqIntegral);

//ofstream myfile;

//myfile.open ("storage.txt");

//myfile << "x" << "\t \t" << "y" << endl;

            //myfile << i << "\t \t" << j-50 << endl; //subtract j by distance from lower limit of y to 0 (if negative)

//myfile.close();

//TGraph *MyGraph = new TGraph("storage.txt");
